TDD habit 1. write our assertions first, work your way backwards to the required
objects you need to setUp and construct.
- this ensures your unittests are as minimalistic as possible.
- that's powerful: going from describing the "what" the test case does to "how" a test
case tests what it does

- we could start with the set up and then work our way down to our assertion,
--> but the problem is that we may miss some details or include extra steps.

- it's okay to reference objects that don't exist yet,
--> IDE's can help you fill in the gaps for you by creating objects for you.

- ultimately, a unittest answers the question of whether an object does a specific task correctly.
--> e.g. if a library receives a donated movie, does the movie appear in the library's catalogue?

TDD habit 2. testing your test before we make it pass, see the test fail so you know the test is reliable.
- before you write the code to pass the tests, see the test assertion initially fail when the result
is wrong and you get an assertionError, not because of some unhandled exception (which hides the fact
that your code is wrong).

- good tests should act like regression tests: if we extend or modify code, existing test cases should
still pass. unittests should fail if the answer is wrong, so if our changes break our code, the unittests
will catch broken code by easily and quickly identifying which specific part(s) are broken
--> you don't want all of the tests to pass, but have hopelessly broken code because our unittests
aren't meaningful.
--> test cases are more effective when they only have a single responsibility, because you can
easily and quickly isolate why the test case fails.

- if you're stuck with trying to make a test case fail, you can do this by deliberately choosing a
placeholder value that fails the unittest.
--> sometimes the implementation is easy or obvious and it's not worth your time "triangulating" and
taking extra steps on purpose.

TDD habit 3: write the simplest code that makes all test cases pass